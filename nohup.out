
> @ start /home/pi/Public/express-blog
> nodemon app.js

[33m[nodemon] 1.11.0[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching: *.*[39m
[32m[nodemon] starting `node app.js`[39m
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: EBADF: bad file descriptor, read

npm ERR! Linux 4.4.38-v7+
npm ERR! argv "/usr/bin/nodejs" "/usr/bin/npm" "start"
npm ERR! node v7.4.0
npm ERR! npm  v4.0.5
npm ERR! code ELIFECYCLE
npm ERR! @ start: `nodemon app.js`
npm ERR! Exit status 1
npm ERR! 
npm ERR! Failed at the @ start script 'nodemon app.js'.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the  package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     nodemon app.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs 
npm ERR! Or if that isn't available, you can get their info via:
npm ERR!     npm owner ls 
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     /home/pi/Public/express-blog/npm-debug.log
Server started on port 3000
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    

> @ start /home/pi/Public/express-blog
> nodemon app.js

[33m[nodemon] 1.11.0[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching: *.*[39m
[32m[nodemon] starting `node app.js`[39m
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: EBADF: bad file descriptor, read

npm ERR! Linux 4.4.38-v7+
npm ERR! argv "/usr/bin/nodejs" "/usr/bin/npm" "start"
npm ERR! node v7.4.0
npm ERR! npm  v4.0.5
npm ERR! code ELIFECYCLE
npm ERR! @ start: `nodemon app.js`
npm ERR! Exit status 1
npm ERR! 
npm ERR! Failed at the @ start script 'nodemon app.js'.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the  package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     nodemon app.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs 
npm ERR! Or if that isn't available, you can get their info via:
npm ERR!     npm owner ls 
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     /home/pi/Public/express-blog/npm-debug.log
Server started on port 3000
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`username` = 'Lachlan' LIMIT 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): INSERT INTO `Posts` (`id`,`title`,`body`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'Blog from scratch part 2: MySQL and Sequelize','Content','2017-02-01 14:30:36','2017-02-01 14:30:36');
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
Content
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): UPDATE `Posts` SET `title`='Blog from scratch #2: MySQL and Sequelize',`body`='To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.\r\n\r\nFirst, npm install the required libraries:\r\n\r\n  `npm install -S mysql mysql2 sequelize`\r\n\r\nYou will also want to install the sequelize cli tool:\r\n\r\n  `npm install -g sequelize-cli`\r\n\r\nAlso install MySQL from Oracle.\r\n\r\nBefore getting started with Sequelize, make the database. From the terminal, run\r\n\r\n  `mysql -uroot -p` \r\n\r\nThen enter the root user password decided when you installed MySQL. Next, create two databases: \"blog\", and \"blog_test\". The second will be use with the test suite.\r\n\r\nHead back to your blog project, and run\r\n\r\n  `sequelize init`. \r\n\r\nIt will make a bunch of folders. One of the folders is called \'config\' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add \"blog\" as the database, and \"blog_test\" in test.\r\n\r\nNow to use migrations to generate the tables. First, a \'post\' table, to save our posts. Run the following command:\r\n\r\n  `sequelize model:create --name Post --attributes title:string,content:text`\r\n\r\nThis will create a file in \'migrations\'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:\r\n\r\n  `sequelize db:migrate`\r\n\r\nAnd check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.\r\n\r\nNext post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.',`updatedAt`='2017-02-01 14:49:12' WHERE `id` = 2
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): UPDATE `Posts` SET `title`='Blog from scratch #2: MySQL and Sequelize',`body`='To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.\r\n\r\nFirst, npm install the required libraries:\r\n\r\n  `npm install -S mysql mysql2 sequelize`\r\n\r\nYou will also want to install the sequelize cli tool:\r\n\r\n  `npm install -g sequelize-cli`\r\n\r\nAlso install MySQL from Oracle.\r\n\r\nBefore getting started with Sequelize, make the database. From the terminal, run\r\n\r\n  `mysql -uroot -p` \r\n\r\nThen enter the root user password decided when you installed MySQL. Next, create two databases: \"blog\", and \"blog_test\". The second will be use with the test suite.\r\n\r\nHead back to your blog project, and run\r\n\r\n  `sequelize init`. \r\n\r\nIt will make a bunch of folders. One of the folders is called \'config\' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add \"blog\" as the database, and \"blog_test\" in test.\r\n\r\nNow to use migrations to generate the tables. First, a \'post\' table, to save our posts. Run the following command:\r\n\r\n  `sequelize model:create --name Post \r\n  --attributes title:string,content:text`\r\n\r\nThis will create a file in \'migrations\'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:\r\n\r\n  `sequelize db:migrate`\r\n\r\nAnd check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.\r\n\r\nNext post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.\r\n    ',`updatedAt`='2017-02-01 14:50:16' WHERE `id` = 2
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`username` = 'Lachlan' LIMIT 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`username` = 'Lachlan' LIMIT 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
2
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 2;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): INSERT INTO `Posts` (`id`,`title`,`body`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'Blog from scratch #3: Routing','This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.\r\n\r\nIn the root folder, make a folder called \"routes\", containing a file called \"posts.js\". In posts.js, insert the following code:\r\n\r\nconst router = require(\"express\").Router()\r\nconst Post   = require(\"../models\").Post\r\n\r\nBefore writing the actual logic, let\'s write the tests. Inside of test/routes, make a file called \"posts.spec.js\". Inside that file, write the following code:\r\n\r\nconst request  = require(\"supertest\")\r\nconst Bluebird = require(\"bluebird\")\r\nconst app      = require(\"../../app\")\r\nconst expect   = require(\"chai\").expect\r\nconst models   = require(\"../../models\")\r\n\r\ndescribe(\"/posts\", () => {\r\n  before(() => {\r\n    models.sequelize.sync()\r\n  })\r\n\r\n  beforeEach(() => {\r\n    this.models = models\r\n    return Bluebird.all([\r\n      this.models.Post.destroy({\r\n        truncate: true\r\n      })\r\n    ])\r\n  })\r\n})\r\n\r\nThere is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run \r\n\r\n  `npm install -D bluebird`\r\n\r\nTo install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.\r\n\r\nIn `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.\r\n\r\nNow, I will write a test for the a GET request as follows:\r\n\r\n(\"/:id returns a post\", (done) => {\r\n  this.models.Post.create({\r\n    title: \"Title\",\r\n      content: \"Content\"\r\n  }).then(() => {\r\n    request(app)\r\n      .get(\"/posts/1\")\r\n      .expect(200, /Title/)\r\n      .expect(200, /Content/)\r\n      .end(done)\r\n    })\r\n})','2017-02-04 06:11:50','2017-02-04 06:11:50');
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): UPDATE `Posts` SET `title`='Blog from scratch #3: Routing',`body`='This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.\r\n\r\nIn the root folder, make a folder called \"routes\", containing a file called \"posts.js\". In posts.js, insert the following code:\r\n\r\nconst router = require(\"express\").Router()\r\nconst Post   = require(\"../models\").Post\r\n\r\nBefore writing the actual logic, let\'s write the tests. Inside of test/routes, make a file called \"posts.spec.js\". Inside that file, write the following code:\r\n\r\nconst request  = require(\"supertest\")\r\nconst Bluebird = require(\"bluebird\")\r\nconst app      = require(\"../../app\")\r\nconst expect   = require(\"chai\").expect\r\nconst models   = require(\"../../models\")\r\n\r\ndescribe(\"/posts\", () => {\r\n  before(() => {\r\n    models.sequelize.sync()\r\n  })\r\n\r\n  beforeEach(() => {\r\n    this.models = models\r\n    return Bluebird.all([\r\n      this.models.Post.destroy({\r\n        truncate: true\r\n      })\r\n    ])\r\n  })\r\n})\r\n\r\nThere is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run \r\n\r\n  `npm install -D bluebird`\r\n\r\nTo install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.\r\n\r\nIn `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.\r\n\r\nNow, I will write a test for the a GET request as follows:\r\n\r\n(\"/:id returns a post\", (done) => {\r\n  this.models.Post.create({\r\n    title: \"Title\",\r\n      content: \"Content\"\r\n  }).then(() => {\r\n    request(app)\r\n      .get(\"/posts/1\")\r\n      .expect(200, /Title/)\r\n      .expect(200, /Content/)\r\n      .end(done)\r\n    })\r\n})\r\n\r\nRunning the test using the npm script from #1 (`npm test`) produces:\r\n\r\n  Error: expected 200 \"OK\", got 404 \"Not Found\"\r\n\r\nAs expected - we haven\'t made the page, or route. Let\'s do that now. Navigate to routes/posts.js, and add the following code:\r\n\r\nrouter.get(\"/:id\", (req, res) => {\r\n  Post.findOne({\r\n    where: {\r\n      id: parseInt(req.params.id)\r\n    }\r\n  }).then((post) => {\r\n    res.locals.post = post\r\n    \r\n    return res.render(\"posts/show\")\r\n  })\r\n})\r\n\r\nmodule.exports = router\r\n\r\nUsing the id parameter, we simply get the post from the database using sequelize\'s \"findOne\" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.\r\n\r\nNext, create a folder in the root directory of the application called \"views\", containing another folder called \"posts\", which contains a file called \"show.ejs\". the .ejs extension allows us to embed javascript in regular html views.\r\n\r\nInside show.ejs, add the following:\r\n\r\n<%= post.title %>\r\n<%= post.content %>\r\n\r\nThis is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.\r\n\r\nNavigate to app.js, and \r\n\r\n  `const posts = require(\"./routes/posts\")`\r\n\r\n\r\nAt the top of the file, then add the following:\r\n\r\nconst router = express.Router()\r\n\r\napp.set(\"views\", \"views\")\r\napp.set(\"view engine\", \"ejs\")\r\n\r\nrouter.use(\"/posts\", posts)\r\napp.use(router)\r\n\r\nThis will let the app know where to find the views, the routes, and to use the routes.\r\n\r\nIf everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. \r\n\r\nHere is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing\r\n\r\nNext post will deal with POST requests.\r\n\r\n\r\n\r\n',`updatedAt`='2017-02-04 07:20:53' WHERE `id` = 3
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 3;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.





> @ start /home/pi/Public/express-blog
> nodemon app.js

[33m[nodemon] 1.11.0[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching: *.*[39m
[32m[nodemon] starting `node app.js`[39m
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: EBADF: bad file descriptor, read

npm ERR! Linux 4.4.38-v7+
npm ERR! argv "/usr/bin/nodejs" "/usr/bin/npm" "start"
npm ERR! node v7.4.0
npm ERR! npm  v4.0.5
npm ERR! code ELIFECYCLE
npm ERR! @ start: `nodemon app.js`
npm ERR! Exit status 1
npm ERR! 
npm ERR! Failed at the @ start script 'nodemon app.js'.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the  package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     nodemon app.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs 
npm ERR! Or if that isn't available, you can get their info via:
npm ERR!     npm owner ls 
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     /home/pi/Public/express-blog/npm-debug.log
Server started on port 3000

> @ start /home/pi/Public/express-blog
> nodemon app.js

[33m[nodemon] 1.11.0[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching: *.*[39m
[32m[nodemon] starting `node app.js`[39m
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: EBADF: bad file descriptor, read

npm ERR! Linux 4.4.38-v7+
npm ERR! argv "/usr/bin/nodejs" "/usr/bin/npm" "start"
npm ERR! node v7.4.0
npm ERR! npm  v4.0.5
npm ERR! code ELIFECYCLE
npm ERR! @ start: `nodemon app.js`
npm ERR! Exit status 1
npm ERR! 
npm ERR! Failed at the @ start script 'nodemon app.js'.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the  package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     nodemon app.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs 
npm ERR! Or if that isn't available, you can get their info via:
npm ERR!     npm owner ls 
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     /home/pi/Public/express-blog/npm-debug.log
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE :::3000
    at Object.exports._errnoException (util.js:1022:11)
    at exports._exceptionWithHostPort (util.js:1045:20)
    at Server._listen2 (net.js:1262:14)
    at listen (net.js:1298:10)
    at Server.listen (net.js:1376:9)
    at Function.listen (/home/pi/Public/express-blog/node_modules/express/lib/application.js:617:24)
    at Object.<anonymous> (/home/pi/Public/express-blog/app.js:42:5)
    at Module._compile (module.js:571:32)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:488:32)
    at tryModuleLoad (module.js:447:12)
    at Function.Module._load (module.js:439:3)
    at Module.runMain (module.js:605:10)
    at run (bootstrap_node.js:420:7)
    at startup (bootstrap_node.js:139:9)
    at bootstrap_node.js:535:3
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE :::3000
    at Object.exports._errnoException (util.js:1022:11)
    at exports._exceptionWithHostPort (util.js:1045:20)
    at Server._listen2 (net.js:1262:14)
    at listen (net.js:1298:10)
    at Server.listen (net.js:1376:9)
    at Function.listen (/home/pi/Public/express-blog/node_modules/express/lib/application.js:617:24)
    at Object.<anonymous> (/home/pi/Public/express-blog/app.js:42:5)
    at Module._compile (module.js:571:32)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:488:32)
    at tryModuleLoad (module.js:447:12)
    at Function.Module._load (module.js:439:3)
    at Module.runMain (module.js:605:10)
    at run (bootstrap_node.js:420:7)
    at startup (bootstrap_node.js:139:9)
    at bootstrap_node.js:535:3
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`username` = 'Lachlan' LIMIT 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): INSERT INTO `Posts` (`id`,`title`,`body`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'Javascript: Values and Expressions','In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let\'s see it in action:\r\n\r\n34\r\n//=> 34\r\n\r\nIs 34 an expression? A value? \r\n\r\nBOTH! It is both. All values are expressions.\r\n\r\nHow about \"Hello\" + \" World\"?\r\n\r\n//=> \'Hello World\'\r\n\r\n\"Hello\" and \"World\" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.\r\n\r\nThere are two different classes of variables in Javascript: value types, and reference types. \r\n\r\nValue Types\r\n\r\nSome value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:\r\n\r\n2 + 2 === 4\r\n//=> true\r\n\r\n\'Hello\' === \'Hello\'\r\n//=> true\r\n\r\nThese are called primitive types, or value types.\r\n\r\nReference Types\r\n\r\nWhat kind of object might have the same content as another, but not be identical? How about an array:\r\n\r\n[1, 2] === [1, 2]\r\n//=> false\r\n\r\n\r\n\r\n\r\n','2017-02-16 12:29:09','2017-02-16 12:29:09');
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
4
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 4;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false





Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
4
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 4;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 4;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): UPDATE `Posts` SET `title`='Javascript: Values and Expressions',`body`='In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let\'s see it in action:\r\n\r\n34\r\n//=> 34\r\n\r\nIs 34 an expression? A value? \r\n\r\nBOTH! It is both. All values are expressions.\r\n\r\nHow about \"Hello\" + \" World\"?\r\n\r\n//=> \'Hello World\'\r\n\r\n\"Hello\" and \"World\" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.\r\n\r\nThere are two different classes of variables in Javascript: value types, and reference types. \r\n\r\nValue Types\r\n\r\nSome value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:\r\n\r\n2 + 2 === 4\r\n//=> true\r\n\r\n\'Hello\' === \'Hello\'\r\n//=> true\r\n\r\nThese are called primitive types, or value types.\r\n\r\nReference Types\r\n\r\nWhat kind of object might have the same content as another, but not be identical? How about an array:\r\n\r\n[1, 2] === [1, 2]\r\n//=> false\r\n\r\nWhen you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.\r\n\r\n',`updatedAt`='2017-02-16 12:32:12' WHERE `id` = 4
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
4
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 4;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


4
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 4;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Server started on port 3000
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`username` = 'Lachlan' LIMIT 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): INSERT INTO `Posts` (`id`,`title`,`body`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'Developing a Tetris clone in Vue.js','To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.\r\n\r\nThree major things I learned during development:\r\n\r\n1. The value of a good test suite\r\nTesting something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.\r\n\r\n2. Planning \r\nJust jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. \r\n\r\n3. More rigorous testing\r\nWhen I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.\r\n\r\n\r\nThis was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.','2017-02-19 10:51:31','2017-02-19 10:51:31');
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
5
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 5;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
5
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 5;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
1
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
5
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 5;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`username` = 'Lachlan' LIMIT 1;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Logged in as Lachlan
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue.js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
5
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 5;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 5;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): UPDATE `Posts` SET `title`='Developing a Tetris clone in Vue.js',`body`='To learn more about Vue js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.\r\n\r\nThree major things I learned during development:\r\n\r\n1. The value of a good test suite\r\nTesting something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.\r\n\r\n2. Planning \r\nJust jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. \r\n\r\n3. More rigorous testing\r\nWhen I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.\r\n\r\n\r\nThis was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.\r\n    ',`updatedAt`='2017-02-19 12:30:27' WHERE `id` = 5
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
5
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post` WHERE `Post`.`id` = 5;
Executing (default): SELECT `id`, `username`, `password`, `createdAt`, `updatedAt` FROM `Users` AS `User` WHERE `User`.`id` = 1;
Executing (default): SELECT `id`, `title`, `body`, `createdAt`, `updatedAt` FROM `Posts` AS `Post`;
In this series of posts, I will be building a blog from scratch using modern TDD best practises. I will also be setting up and hosting the blog myself on a raspberry pi. The stack is as follows:

- Node.JS + Express for the server side
- MySQL for the database
- Nginx for the HTTP server (on a raspberry pi)
- Sequelize to build and maintain the database schema
- Passport for authentication
- Mocha, chai and supertest for testing 

This first post will install the dependencies and setup for development.

First things first, install Node.JS following the instructions and make a folder to hold the blog. Next, run the following command:

    `echo { } >> package.json`

This creates a new file, package.json, which is used to store all the npm dependencies. Next, install the initial dependencies by running the following command:

    `npm install --save express ejs`

We need express for the framework, and `ejs` for embedded javascript. This will let us write javascript inside of our html templates.

Next install the dev-dependencies. These are only required during development, thus the name.

    `npm install --save-dev mocha cross-env chai supertest cheerio`

`mocha` , `cross-env` and `chai` are required to run the tests, and `supertest` and `cheerio` will let us control our application from within the test suite.

Now we are ready to code. Finally.

Start by creating a file called `app.js`, and a folder called tests containing another folder called routes. This is where our first test will go!

Let's create a simple express app to get started. Inside of `.app.js`, add the following:

const express = require("express")
 
const app = express()

app.get("/", (req, res) => {
    res.send("Hello from express!")
})

app.listen(
    console.log("App listening on port 4000.");
})

module.exports = app

Now run `node app.js` and navigate to localhost:4000. You should see "Hello from express!"

Before we go any further, let's write a simple test, to get in the habit of doing so. Normally you write the test *before* implementing the feature.

Inside of test/routes create a file called `index.spec.js`, and insert the following code:

const request = require("supertest")
const app        = require("../../app")
const expect   = require("chai").expect

describe("/", () => {
    it("returns a message", (done) => {
      request(app)
        .get("/")
        .expect(200)
        .end((err, res) => {
          expect(res.text).to.equal("Hello from express!")
          done()
       })
    }
}

To run the test, type 

    `mocha test/routes/index.spec.js`. You should some output  with the description of what the test is doing, and '1 passing'! Try changing the expect statement - the test should fail. Now we can move forward, knowing if we make and breaking changes, our test suite will let us know.


Next post we will set up the database and get started on persisting some posts.
    
To store the data for the blog, and to manage the schema, I will use Sequelize, an ORM for Node. It allows you to use migrations to build the database schema incrementally, and access data without writing raw SQL.

First, npm install the required libraries:

  `npm install -S mysql mysql2 sequelize`

You will also want to install the sequelize cli tool:

  `npm install -g sequelize-cli`

Also install MySQL from Oracle.

Before getting started with Sequelize, make the database. From the terminal, run

  `mysql -uroot -p` 

Then enter the root user password decided when you installed MySQL. Next, create two databases: "blog", and "blog_test". The second will be use with the test suite.

Head back to your blog project, and run

  `sequelize init`. 

It will make a bunch of folders. One of the folders is called 'config' and contains `config.json`. Open that file and enter the database password, and the name database. For example, in the development section, add "blog" as the database, and "blog_test" in test.

Now to use migrations to generate the tables. First, a 'post' table, to save our posts. Run the following command:

  `sequelize model:create --name Post 
  --attributes title:string,content:text`

This will create a file in 'migrations'. Take a look at it for more details. It describes what change to make to the database schema. To change the database, we need to apply the migration - just making it is not enough. Run:

  `sequelize db:migrate`

And check the development database! A new table with the fields was created, along with a primary key `id` and `createdAt` and `updatedAt` fields.

Next post will look at creating a route to insert a post, and writing a test to make sure the functionality is correct.
    
This post will continue on from the previous one, where I setup a database using sequelize. I will add routing, and demonstrating how to test both GET and POST requests.

In the root folder, make a folder called "routes", containing a file called "posts.js". In posts.js, insert the following code:

const router = require("express").Router()
const Post   = require("../models").Post

Before writing the actual logic, let's write the tests. Inside of test/routes, make a file called "posts.spec.js". Inside that file, write the following code:

const request  = require("supertest")
const Bluebird = require("bluebird")
const app      = require("../../app")
const expect   = require("chai").expect
const models   = require("../../models")

describe("/posts", () => {
  before(() => {
    models.sequelize.sync()
  })

  beforeEach(() => {
    this.models = models
    return Bluebird.all([
      this.models.Post.destroy({
        truncate: true
      })
    ])
  })
})

There is some new stuff here. Firstly, we are requiring `bluebird`, which will allow use to use promises in our test. Ensure to run 

  `npm install -D bluebird`

To install bluebird. In the `before()` function, we sync the models to the database - we usually run migrations on our development database, but not the test one, so this ensures the test database schema is also up to date.

In `beforeEach`, we clear the database. This makes sure thea tests are all run on a clean database, and the test environment is consistent and predictable.

Now, I will write a test for the a GET request as follows:

("/:id returns a post", (done) => {
  this.models.Post.create({
    title: "Title",
      content: "Content"
  }).then(() => {
    request(app)
      .get("/posts/1")
      .expect(200, /Title/)
      .expect(200, /Content/)
      .end(done)
    })
})

Running the test using the npm script from #1 (`npm test`) produces:

  Error: expected 200 "OK", got 404 "Not Found"

As expected - we haven't made the page, or route. Let's do that now. Navigate to routes/posts.js, and add the following code:

router.get("/:id", (req, res) => {
  Post.findOne({
    where: {
      id: parseInt(req.params.id)
    }
  }).then((post) => {
    res.locals.post = post
    
    return res.render("posts/show")
  })
})

module.exports = router

Using the id parameter, we simply get the post from the database using sequelize's "findOne" method. To let the view (which will be created soon) to access the post, I pass it using res.locals, by which you can pass any object to the view. Lastly, we render the view we are about to create. The final line exports the router (and routes we add) so the app can access them.

Next, create a folder in the root directory of the application called "views", containing another folder called "posts", which contains a file called "show.ejs". the .ejs extension allows us to embed javascript in regular html views.

Inside show.ejs, add the following:

<%= post.title %>
<%= post.content %>

This is what our test looks for - the title and content of the post. This should be enough to get our test to pass, however running `npm test` will still yield the 404 error. Just creating the route is not enough; we need to tell the app to use it.

Navigate to app.js, and 

  `const posts = require("./routes/posts")`


At the top of the file, then add the following:

const router = express.Router()

app.set("views", "views")
app.set("view engine", "ejs")

router.use("/posts", posts)
app.use(router)

This will let the app know where to find the views, the routes, and to use the routes.

If everything went well, running `npm test` should yield two passing tests! Without even running the app, we are confident the functionality is working. 

Here is a branch showing the current state of the app thusfar: https://github.com/lmiller1990/blog-tutorial/tree/part-3-routing

Next post will deal with POST requests.




In Javascript, you give a the compiler (web browser or otherwise) an expression, and in return, you get a value. Let's see it in action:

34
//=> 34

Is 34 an expression? A value? 

BOTH! It is both. All values are expressions.

How about "Hello" + " World"?

//=> 'Hello World'

"Hello" and "World" are string values; combined with the + operator, we have an expression, which the compiler evaluates, returning a value.

There are two different classes of variables in Javascript: value types, and reference types. 

Value Types

Some value types are booleans, strings and numbers. When compared using the === equality operator, the comparison is based on the contents of the variable:

2 + 2 === 4
//=> true

'Hello' === 'Hello'
//=> true

These are called primitive types, or value types.

Reference Types

What kind of object might have the same content as another, but not be identical? How about an array:

[1, 2] === [1, 2]
//=> false

When you make an array, even if the contents are the same as another, the array is unique; it is like other array that ever was, or ever will be. This is also true of functions.


To learn more about Vue js, and test driven development with Mocha, I developed a simple clone of the classic game Tetris. Visit the projects section of this blog to check it out. I used the vue-cli webpack project as a base, which comes with mocha for unit tests, and nightwatch for e2e tests.

Three major things I learned during development:

1. The value of a good test suite
Testing something like this would have been very slow and tedious - considering all the different possible cases with different shaped blocks, using TDD was the best approach. Especially when implementing the rotation of blocks, the test suite made is much easier to make sure edge cases were all covered.

2. Planning 
Just jumping into the project without planning led me to have to rewrite some parts. I did not add color to the blocks until the very end - and the way I handled moving blocks around the board made it very difficult. Next time, I will look at the big picture and consider how each part fits together. 

3. More rigorous testing
When I started the project, I focused on making a single flat block fall. Then move left and right. Then rotate. After this I went to implemented more complex shaped blocks, like an L shaped block and a Z shaped block, and found they did not move left and right correctly. Instead of going straight to left/right movement after making a simple block fall, next time, after making the first functionality work on a simple block, write more tests to ensure it also works on more complex cases, before moving on. While my test suite did catch the problems, it would have been faster and easier overall to have written the tests and been more thorough in the first place.


This was a fun experience and I learned a lot. I hope to using Vue.js more in the future, with the vue-cli webpack project features like hot reloading, linting, and TDD, development was fun and fast.
    
